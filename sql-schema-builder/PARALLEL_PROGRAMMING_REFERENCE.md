# Справка: Параллельное программирование для веб-приложений

## Введение

Современные веб-приложения работают в многопользовательской среде, где важна скорость отклика. Параллельное программирование помогает обрабатывать несколько запросов одновременно.

---

## 1. Многоядерные процессоры и веб-приложения

### Реальность:
- **Node.js однопоточный** — но использует неблокирующий I/O
- **Один поток может обрабатывать тысячи соединений** благодаря event loop

### Когда помогают многоядра:
- CPU-интенсивные задачи (расчёты, шифрование, сжатие)
- Обработка больших объёмов данных
- Пакетная обработка

### Когда НЕ помогают:
- Простые CRUD операции
- Работа с базой данных (обычно I/O bound)
- Отдача статических файлов

---

## 2. Подходы к параллелизму в Node.js

### А) Кластеры (Cluster API)
```javascript
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
} else {
  // Рабочий процесс
  app.listen(3000);
}
```

**Эффект:** Использует все ядра CPU для отдельных процессов.

---

### Б) Worker Threads
```javascript
const { Worker } = require('worker_threads');

const worker = new Worker('./heavy-task.js');
worker.on('message', result => console.log(result));
```

**Эффект:** Выполнение CPU-интенсивного кода в отдельном потоке.

---

### В) Параллельные библиотеки

#### Rayon (Rust)
```rust
use rayon::prelude::*;

let result: u64 = (0..1000000)
    .into_par_iter()
    .map(|x| x * x)
    .sum();
```

**Эффект:** Автоматическое распараллеливание итераций.

---

### Г) Web Workers (браузер)
```javascript
const worker = new Worker('worker.js');
worker.postMessage({ data: 'обработай' });
worker.onmessage = (e) => console.log(e.data);
```

**Эффект:** Тяжёлые вычисления в браузере не блокируют UI.

---

## 3. Когда это актуально для SQL Schema Builder?

### Наш проект:
- ✅ Визуальное редактирование схем — однопоточный Node.js справляется
- ✅ Генерация SQL — простые строковые операции, не требуют параллелизма
- ✅ Сохранение в localStorage — синхронная операция

### Потенциальные места для параллелизма:
- Генерация SQL для очень большой схемы (100+ таблиц)
- Экспорт в несколько форматов одновременно
- Валидация связей между таблицами

### Вердикт:
**Для учебного проекта достаточно однопоточной модели Node.js.** Многоядерность не даст видимого прироста для типичных операций.

---

## 4. Облачные решения

В облаке параллелизм решается **горизонтальным масштабированием**:

```
                    ┌─────────────┐
                    │  Load       │
                    │  Balancer   │
                    └──────┬──────┘
           ┌──────────────┼──────────────┐
           ▼              ▼              ▼
      ┌─────────┐   ┌─────────┐   ┌─────────┐
      │ Server 1│   │ Server 2│   │ Server 3│
      │ (Core 1)│   │ (Core 2)│   │ (Core 3)│
      └─────────┘   └─────────┘   └─────────┘
```

**Это не требует специального кода** — облако само распределяет нагрузку.

---

## 5. Рекомендации для курса "Основы параллельного программирования"

### Практические примеры для демонстрации:

1. **Сравнение производительности:**
   - Однопоточный vs многопоточный расчёт факториала
   - Однопоточный vs параллельный поиск простых чисел

2. **Web Workers в браузере:**
   - Демонстрация блокировки UI при тяжёлых вычислениях
   - Как Worker решает проблему

3. **Node.js Cluster:**
   - Простой пример с использованием всех ядер CPU

4. **Асинхронное программирование:**
   - Promise vs async/await
   - Параллельное выполнение Promise.all()

---

## 6. Код для демонстрации

### Пример: Параллельный поиск простых чисел (Rust/Rayon)

```rust
fn is_prime(n: u64) -> bool {
    if n <= 1 { return false; }
    for i in 2..=((n as f64).sqrt() as u64) {
        if n % i == 0 { return false; }
    }
    true
}

fn main() {
    let range = 1..=100000;
    
    // Параллельно
    let start = std::time::Instant::now();
    let count: u64 = range.into_par_iter()
        .filter(|&x| is_prime(x))
        .count();
    println!("Найдено простых чисел: {}", count);
    println!("Время (параллельно): {:?}", start.elapsed());
}
```

---

## 7. Выводы

| Задача | Нужен параллелизм? |
|--------|-------------------|
| CRUD операции | ❌ Нет |
| Генерация SQL | ❌ Нет |
| Валидация схемы | ❌ Нет |
| Обработка 10000+ таблиц | ✅ Да |
| Сложные математические расчёты | ✅ Да |
| Сжатие/шифрование больших файлов | ✅ Да |

**Главное правило:** Начинайте с простого решения. Добавляйте сложность только тогда, когда профилирование покажет узкое место.

---

## Версия: v1.0
## Для курса: Основы параллельного программирования
## Автор: Koda
## Дата: 2024
